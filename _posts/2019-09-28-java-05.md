---
title:  "Java-객체, 클래스, 메소드"
excerpt: "Java-객체, 클래스, 메소드"
toc: true
toc_sticky: true  
categories:
  - Java
last_modified_at: 2019-09-28
---

## **객체**
- 객체란?
    - 데이터 + 기능 결합한 구조


- **객체의 일생**
    1. 객체의 생성 : new연산자를 이용해서 힙영역에 객체가 생성됨.
    2. 객체의 사용 : 참조변수 (ex : mycar) 를 이용해서 속성 및 메소드를 사용함.
    3. 객체의 소멸 : 참조를 잃으면 (객체를 참조하고 있는 참조변수가 없다면 ) 가비지 컬렉터에 의해 소멸됨.


- . 도트연산자 → 객체의 메소드를 호출할 때 사용         ex → mycar.print();
- new 연산자 → 무조건 객체를 생성할 때 사용    ex → Car mycar = new Car()
    - Car mycar = new Car(); → 작동과정


1. 연산자 new에 의해서 메모리(heap)에 Car클래스의 인스턴스가 생성된다.
2. 생성자 Car()이 호출 되어 수행된다.
3. 연산자 new의 결과로, 생성된 Car인스턴스의 주소가 반환되어 참조변수 mycar에 저장된다.


## **클래스**

클래스 : 객체를 생성하기 위한 툴
구조 : [public] class 클래스이름 {}  

- **객체지향 프로그램의 순서**
    1. 만들고 싶은 존재(객체)를 만들어내기위한 틀(class)를 먼저 생성
    2. 틀(class)를 선언(생성)한 다음에는 필요할 때마다 객체(object, instance)를 만들어서 각자의 필요에 맞게 사용

- 필드의 값을 메소드 내에서 변경하여 새롭게 저장할 수 있고 사용해서 기능(ex:출력)으로 이용할 수도 있음.
- 객체지향프로그램은 클래스 구조 설계에 초점을 맞춤.
- 클래스 나중에 재사용할 것을 고려해서 만드는 틀(데이터 + 로직)이기 때문에 이 기능들을 실행하기 위한 main메소드는 만들지 않음.
- 설계클래스 : 클래스 구조에 집중
- 실행클래스 : main 메소드가 있어서 객체를 생성하여 기능들을 사용하는 클래스
- 이렇게 두 가지로 나뉘어져있다는 것을 확실히 정립해야 나중에 이해가 잘됨.
- ex) Car mycar = new Car();  → 객체 생성
- 클래스인 Car은 참조타입 → 객체가 생성된 곳의 주소를 mycar 변수에 저장한다.


- **클래스의 구성**

public class 클래스 이름 { 필드, 생성자, 메소드 }

- **클래스에서의 변수 vs 필드**

- 멤버변수 : 생성자와 메소드 블록 {} 내에서만 사용되고 생성자와 메소드가 실행종료되면 자동으로 소멸함.
- 필드 : 클래스 블록 {} 내에서 어디든지 선언가능 (생성자와 메소드 안에서는 제외, 이건 변수) 


- **Tip**

한 클래스가 선언된 소스파일 안에 여러 개의 클래스가 존재할 수 있는데 무조건 public은 제목클래스에만 붙어야한다.
```java
    class Adder{
    
    }
    public class AdderTest {
    
    }
```  
    
## **public과 private** 
- main 메소드를 가지지 않는 대부분의 클래스는 외부클래스에서 이용할 목적으로 설계된 라이브러리 클래스
- 라이브러리 클래스를 설계할 때는 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버를 구분하는 것이 바람직함.
- 이러한 기능을 구현하기 위해 접근제한자(public, private)을 사용함.
- 클래스 내부에서만 쓰게끔 하려면 private을 붙히고 외부에서도 사용할 수 있게 하려면 public붙힌다.
- public : 모든 클래스로부터 접근 가능.
- **private : 클래스 내부에서만 접근 가능.**


## **getter/setter 메소드**
- 일반적으로 객체지향 프로그래밍에서 객체의 데이터(필드,메소드 등등)는 객체 외부에서 직접적으로 접근하는 것을 막음. →(private으로 막는다.) → 이유 : 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결점이 깨질 가능성이 커짐.
- **setter 메소드** (쓰기 전용)
    - 예를 들어 외부에서 직접 데이터에 접근하여 Car객체의 speed를 음수로 설정하면 우리가 설계한 Car클래스에 결점이 생김. 
    - 이러한 문제점을 해결하기 위해서 메소드를 통해 데이터를 변경하는 방법을 선호함.
    - 이게 바로 설정자 setter 메소드 -> 필드의 값을 설정하는 메소드 (ex : 외부에서 속도값을 하나 받아서 속도필드에 넣어주는 메소드 / 외부에서 받은 값이 0~300일 경우만 저장되게하는 메소드) → 입력값에 대한 검증이 가능하다는 장점이 있음.
    1. 접근 제한자 : public
    2. 반환유형 : void
    3. 메소드이름 : set+필드명
    4. 매개변수 : setter를 통해서 필드에 설정하고자하는 데이터 타입과 같은 매개변수
    5. 실행코드 : 필드 = 매개변수;
```java
            public void setSpeed(int speed) {
                    if (speed >=0 && speed <=300) {
                            this.speed = speed;
                    }
            }
```            
- **getter 메소드** (읽기 전용)
    1. 접근 제한자 : public
    2. 반환유형 : getter메소드를 통해 리턴하고자 하는 필드의 데이터타입
    3. 메소드이름 : get+필드명 
    4. 매개변수 : 없음
    5. 실행코드 : return 필드명;
    public int getSpeed() {
                    return speed;
            }
- **setter/getter 메소드 사용이유**
    1. 외부에서 데이터 직접 접근하는 것을 막기 위해서
    2. 입력값에 대한 검증 가능
    3. 세분화된 접근제어 가능


## **메소드**
- 1~100 합을 구하는 프로그램을 만든 후에 나중에 해당 코드를 재사용하는 방법은? -> 복사 붙여넣기가 있지만 이건 굉장히 귀찮고 비효율적이다.
- 수정 시 복붙한 곳의 모든 곳을 수정해야하기 때문
- 복붙대신에 쓰는 방법이 있는데 그것이 바로 **메소드**
- **메소드** : 로직이나 기능을 하나로 묶어서 한 덩어리로 만들고 관리해주는 애
- 매개변수 : 형식은 변수 선언하는 것과 같다.
- 반환형 : void → 반환할 값이 없을 때 쓰는 것. (있을 때는 결과값의 데이터타입으로 씀.)


- 반환할 값이 있을 때 결과값 리턴하는 순서
    1. 돌려줄 결과값의 형태를 미리 정해둠
    2. 작업이 끝나고 결과값을 돌려줌
    3. 메소드를 호출하고 얻은 결과값을 main 메소드 안에서 특정 변수에 저장
- return의 의미 : 나를 호출할 곳으로 돌아가!! → 반환형이 있을 때에는 결과값을 가지고 돌아가!!


- 만드는 순서
    1.  어떤 것을 만들지 결정 (두 숫자 사이 모든 값 더하기) 
    2. 이름정하기 (더하기니까 add) 
    3. 형식에 맞게 구현 
    4. 실행여부 판단
- 프로그램 실행 중 가장 먼저 시작되는 건 main메소드 찾아서 실행하기!
- 만약 main메소드에 정의되지 않은 기능이 있다면 찾으러 가서 알아온다.
![](https://d2mxuefqeaa7sj.cloudfront.net/s_598415E9CFBF501893D0F65A3BBC62D05CB525529E9D5A99DB74303C66B0DBFB_1546821784583_aa.png)



## **메소드 오버로딩**
- 정의 : 한 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
- 하나의 기능에다가 여러 개의 매개변수 종류가 넣어지게끔하는 기능.
- 결국 매개변수가 서로 다름
- 메소드 오버로딩의 조건은 매개변수의 타입, 갯수, 순서 중 하나가 달라야함.
```java
    class Adder{
            public void add(int a, int b) {
                    System.out.println("정수더하기 : " +(a + b));
            }
            public void add(double a, double b) {
                    System.out.println("실수더하기 : " +(a + b));
            }
    }
```    
- 위 처럼 동일한 더하기 기능임에도 다루는 데이터가 다르므로 (정수, 실수) 


- 오버로딩 → 매개변수의 타입, 갯수, 순서
- 오버라이딩 → 실행문

